<!DOCTYPE html><html><head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Button | Dash for Python Documentation | Plotly</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="html Button components are commonly used in Dash callbacks.">
    <meta name="google-site-verification" content="EgLBLquJuqD_NR96F-pKLhTy9ZKQlWIoQlexW_OVKrM" />
    <title>Button | Dash for Python Documentation | Plotly</title>
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico?m=1713366137.0">
    
<link href="https://esm.sh/@markprompt/css@0.18.0?css" rel="stylesheet" />

    <link rel="stylesheet" href="/_dash-component-suites/dash_design_kit/ddk-all.v1_10_0m1713366171.css">
<link rel="stylesheet" href="/_dash-component-suites/dash_design_kit/bootstrap_build.v1_10_0m1713366171.css">
<link rel="stylesheet" href="/_dash-component-suites/dash_design_kit/fa-ddk.v1_10_0m1713366171.css">
<link rel="stylesheet" href="/assets/ag-grid-examples-css.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/azure.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/base.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/daq.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/dashbio.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/ddk.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/dosis.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/loading.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/local-css-example.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/markprompt_override.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/open-sans.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/override.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/percy.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/table.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/tabs-styled-with-classes.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/typography.css?m=1713366138.0">
<link rel="stylesheet" href="/assets/dash-design-kit/docs.css?m=1713366214.0">
<link rel="stylesheet" href="/assets/dash-design-kit/gallery-style.css?m=1713366214.0">
<link rel="stylesheet" href="/assets/dash-design-kit/react-resizable.css?m=1713366214.0">
<link rel="stylesheet" href="/assets/dash-design-kit/report.css?m=1713366214.0">
<link rel="stylesheet" href="/assets/font-awesome/css/fontawesome.min.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/font-awesome/css/solid.min.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/highlight/styles/default.css?m=1713366137.0">
<link rel="stylesheet" href="/assets/highlight/styles/dm-mono.css?m=1713366137.0">
    <!-- Google Tag Manager Tag -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-N6T2RXG');</script>

    <style type="text/css">
.placeholder-content{will-change:transform;animation:placeHolderShimmer 1s linear infinite forwards;-webkit-backface-visibility:hidden;background:#e6e6e6;background:linear-gradient(90deg,#eee 8%,#ddd 18%,#eee 33%);background-size:800px 104px;height:100%;position:relative}.placeholder-content *{color:transparent!important;opacity:0}@keyframes placeHolderShimmer{0%{-webkit-transform:translateZ(0);transform:translateZ(0);background-position:-468px 0;opacity:.7}45%{opacity:.8}75%{opacity:1}100%{-webkit-transform:translateZ(0);transform:translateZ(0);background-position:468px 0;opacity:.7}}@keyframes placeholderAnimate{0%{background-position:-650px 0}100%{background-position:650px 0}}.preload{position:fixed;top:0;left:0;right:0;bottom:0;transition:all ease .3s;z-index:99999;background-color:#fff}.preload *{box-sizing:border-box}.preload .pre-sidebar{position:absolute;top:0;left:0;bottom:0;width:300px;background-color:#fafafa}.preload .pre-content{position:absolute;top:0;left:300px;bottom:0;right:0;padding:0 0 0 90px;z-index:999;background-color:#fff}.preload .pre-brand{padding:35px 10px 20px 20px;display:flex;align-items:center;justify-content:space-between}.preload .pre-logo{width:100px;height:30px;flex-shrink:0;border-radius:6px}.preload .pre-switch{display:inline-flex !important;justify-content:flex-end;}.preload .pre-switch .pre-dot{flex-shrink:0;width:20px;height:20px;border-radius:20px;margin:0px !important;}.preload .pre-switch .pre-large{width:45px;height:20px;border-radius:20px;flex-shrink:0;margin:0 6px}.preload .pre-search{height:38px;width:223px;margin:10px 0 40px 36px;border-radius:30px}.preload .pre-line{width:100px;height:15px;margin:0 0 30px 30px;border-radius:3px}.preload .pre-line1{width:125px}.preload .pre-line2{width:135px}.preload .pre-line3{width:145px}.preload .pre-line4{width:245px}.preload .pre-line5{width:225px}.preload .pre-line6{width:235px}.preload .pre-line7{width:150px}.preload .pre-line8{width:180px}.preload .pre-line9{width:190px}.preload .pre-line10{width:120px}.preload .pre-menu{padding:20px 20px 0 0;text-align:right}.preload .pre-menu div{width:100px;display:inline-block;height:20px;border-radius:2px;margin:0 0 0 30px}.preload .pre-wrap{max-width:850px}.preload .pre-headline{height:30px;width:400px;margin:100px 0 70px 2px;border-radius:2px}.preload .pre-subhead{height:23px;width:180px;margin:0 0 28px 0;border-radius:2px}.preload .pre-subhead2{margin:70px 0 28px 0}.preload .pre-box-row{display:flex;flex-wrap:wrap;margin:0 -16px}.preload .pre-box-col{width:33.333%;margin:0 0 20px 0;padding:0 16px}.preload .pre-box{height:112px;width:100%;border-radius:2px}
</style>
</head>
<body>
  <div class="preload">
    <div class="pre-wrap">
      <div class="pre-sidebar">
        <div class="pre-brand">
          <div class="pre-logo placeholder-content">
          </div>
        </div>
        <div class="pre-search placeholder-content">
        </div>
        <div class="pre-line pre-line1 placeholder-content">
        </div>
        <div class="pre-line pre-line2 placeholder-content">
        </div>
        <div class="pre-line pre-line3 placeholder-content">
        </div>
        <div class="pre-line pre-line4 placeholder-content">
        </div>
        <div class="pre-line pre-line5 placeholder-content">
        </div>
        <div class="pre-line pre-line6 placeholder-content">
        </div>
        <div class="pre-line pre-line7 placeholder-content">
        </div>
        <div class="pre-line pre-line8 placeholder-content">
        </div>
        <div class="pre-line pre-line9 placeholder-content">
        </div>
        <div class="pre-line pre-line10 placeholder-content">
        </div>
      </div>
      <div class="pre-content">
        <div class="pre-menu">
          <div class=" placeholder-content">
          </div>
          <div class="pre-switch">
            <div class="pre-dot placeholder-content">
            </div>
            <div class="pre-large placeholder-content">
            </div>
            <div class="pre-dot placeholder-content">
          </div>
          </div>
          <div class=" placeholder-content">
          </div>
          <div class=" placeholder-content">
          </div>
          <div class=" placeholder-content">
          </div>
          <div class=" placeholder-content">
          </div>
        </div>
        <div class="pre-wrap">
          <div class="pre-headline placeholder-content">
          </div>
          <div class="pre-subhead placeholder-content">
          </div>
          <div class="pre-box-row">
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
          </div>
          <div class="pre-subhead pre-subhead2 placeholder-content">
          </div>
          <div class="pre-box-row">
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
            <div class="pre-box-col">
              <div class="pre-box placeholder-content">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
    <!-- Google Tag Manager Tag -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N6T2RXG"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <div id="react-entry-point">
        <div class="ssr-dash-core-components-markdown"><h1 id="button-examples-and-reference"><img alt="" src="/assets/images/language_icons/python_50px.svg" /> Button Examples and Reference</h1>
<p><code>html.Button</code> is a component for rendering a user-selectable button.</p>
<h2 id="examples">Examples</h2>
<p>Find a few usage examples below.</p>
<p>For more examples of minimal Dash apps that use <code>html.Button</code>, go to the community-driven <a href="https://dash-example-index.herokuapp.com/?code=html.Button">Example Index</a>.</p>
<h3 id="button-basic-example">Button Basic Example</h3>
<p>An example of a default button without any extra properties<br />
and <code>n_clicks</code> in the callback. <code>n_clicks</code> is an integer that represents<br />
that number of times the button has been clicked. Note that the original<br />
value is <code>None</code>.</p>
</div>
<div style="position:relative">
<div class="ssr-dash-core-components-clipboard" style="position:absolute; right:10px; top:10px; height:50px">
</div>
 <div class="ssr-dash-core-components-markdown"><pre><code class="python">from dash import Dash, dcc, html, Input, Output, State, callback

app = Dash(__name__)

app.layout = html.Div([
    html.Div(dcc.Input(id='input-on-submit', type='text')),
    html.Button('Submit', id='submit-val', n_clicks=0),
    html.Div(id='container-button-basic',
             children='Enter a value and press submit')
])


@callback(
    Output('container-button-basic', 'children'),
    Input('submit-val', 'n_clicks'),
    State('input-on-submit', 'value'),
    prevent_initial_call=True
)
def update_output(n_clicks, value):
    return 'The input value was &quot;{}&quot; and the button has been clicked {} times'.format(
        value,
        n_clicks
    )


if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
</div>
</div>
<div class="example-container" style=""><div>
<div>
</div>
 <button id="submit-val" n_clicks="false">Submit
</button>
  <div id="container-button-basic">Enter a value and press submit
</div>
</div>
</div>
<div class="ssr-dash-core-components-markdown">
</div>
<div class="dash-club" style="fontSize:0.9em"><div class="ssr-dash-design-kit-card" style="height:50px">
</div>
</div>
<div class="ssr-dash-core-components-markdown"><h3 id="determining-which-button-changed-with-dashctx">Determining which Button Changed with <code>dash.ctx</code></h3>
<p>This example uses the <code>dash.ctx</code> property<br />
to determine which input changed.</p>
<p>Note: <code>dash.ctx</code> is available in Dash 2.4 and later. <code>dash.callback_context</code> provides similar functionality in earlier<br />
versions of Dash.</p>
</div>
<div style="position:relative">
<div class="ssr-dash-core-components-clipboard" style="position:absolute; right:10px; top:10px; height:50px">
</div>
 <div class="ssr-dash-core-components-markdown"><pre><code class="python">from dash import Dash, html, Input, Output, ctx, callback

app = Dash(__name__)

app.layout = html.Div([
    html.Button('Button 1', id='btn-nclicks-1', n_clicks=0),
    html.Button('Button 2', id='btn-nclicks-2', n_clicks=0),
    html.Button('Button 3', id='btn-nclicks-3', n_clicks=0),
    html.Div(id='container-button-timestamp')
])

@callback(
    Output('container-button-timestamp', 'children'),
    Input('btn-nclicks-1', 'n_clicks'),
    Input('btn-nclicks-2', 'n_clicks'),
    Input('btn-nclicks-3', 'n_clicks')
)
def displayClick(btn1, btn2, btn3):
    msg = &quot;None of the buttons have been clicked yet&quot;
    if &quot;btn-nclicks-1&quot; == ctx.triggered_id:
        msg = &quot;Button 1 was most recently clicked&quot;
    elif &quot;btn-nclicks-2&quot; == ctx.triggered_id:
        msg = &quot;Button 2 was most recently clicked&quot;
    elif &quot;btn-nclicks-3&quot; == ctx.triggered_id:
        msg = &quot;Button 3 was most recently clicked&quot;
    return html.Div(msg)

if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
</div>
</div>
<div class="example-container" style=""><div>
<button id="btn-nclicks-1" n_clicks="false">Button 1
</button>
 <button id="btn-nclicks-2" n_clicks="false">Button 2
</button>
  <button id="btn-nclicks-3" n_clicks="false">Button 3
</button>
   <div id="container-button-timestamp">
</div>
</div>
</div>
<div class="ssr-dash-core-components-markdown"><hr />
</div>
<div>
<div class="ssr-dash-core-components-markdown"><h2 id="button-properties">Button Properties</h2>
</div>
 <div class="python-blockquote-ssr-dash-core-components-markdown"><blockquote>
<p>Access this documentation in your Python terminal with:<br />
```python</p>
<blockquote>
<blockquote>
<blockquote>
<p>help(dash.html.Button)<br />
```</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</div>
  <div class="workspaces-blockquote-ssr-dash-core-components-markdown"><blockquote>
<p>Our recommended IDE for writing Dash apps is Dash Enterprise&rsquo;s<br />
<a href="https://plotly.com/dash/workspaces">Data Science Workspaces</a>,<br />
which has typeahead support for Dash Component Properties.<br />
<a href="https://go.plotly.com/company-lookup">Find out if your company is using<br />
Dash Enterprise</a>.</p>
</blockquote>
</div>
   <div class="reference-ssr-dash-core-components-markdown"><p><strong><code>children</code></strong> (<em>list of or a singular dash component, string or number</em>; optional):<br />
The children of this component.</p>
<p><strong><code>id</code></strong> (<em>string</em>; optional):<br />
The ID of this component, used to identify dash components in<br />
callbacks. The ID needs to be unique across all of the components in<br />
an app.</p>
<p><strong><code>n_clicks</code></strong> (<em>number</em>; default <code>0</code>):<br />
An integer that represents the number of times that this element has<br />
been clicked on.</p>
<p><strong><code>n_clicks_timestamp</code></strong> (<em>number</em>; default <code>-1</code>):<br />
An integer that represents the time (in ms since 1970) at which<br />
n_clicks changed. This can be used to tell which button was changed<br />
most recently.</p>
<p><strong><code>disable_n_clicks</code></strong> (<em>boolean</em>; optional):<br />
When True, this will disable the n_clicks prop.  Use this to remove<br />
event listeners that may interfere with screen readers.</p>
<p><strong><code>key</code></strong> (<em>string</em>; optional):<br />
A unique identifier for the component, used to improve performance by<br />
React.js while rendering components See<br />
<a href="https://reactjs.org/docs/lists-and-keys.html">https://reactjs.org/docs/lists-and-keys.html</a> for more info.</p>
<p><strong><code>autoFocus</code></strong> (<em>a value equal to: &lsquo;autoFocus&rsquo;, &lsquo;autofocus&rsquo; or &lsquo;AUTOFOCUS&rsquo; | boolean</em>; optional):<br />
The element should be automatically focused after the page loaded.</p>
<p><strong><code>disabled</code></strong> (<em>a value equal to: &lsquo;disabled&rsquo; or &lsquo;DISABLED&rsquo; | boolean</em>; optional):<br />
Indicates whether the user can interact with the element.</p>
<p><strong><code>form</code></strong> (<em>string</em>; optional):<br />
Indicates the form that is the owner of the element.</p>
<p><strong><code>formAction</code></strong> (<em>string</em>; optional):<br />
Indicates the action of the element, overriding the action defined in<br />
the &lt;form&gt;.</p>
<p><strong><code>formEncType</code></strong> (<em>string</em>; optional):<br />
If the button/input is a submit button (e.g. type=&rdquo;submit&rdquo;), this<br />
attribute sets the encoding type to use during form submission. If<br />
this attribute is specified, it overrides the enctype attribute of the<br />
button&rsquo;s form owner.</p>
<p><strong><code>formMethod</code></strong> (<em>string</em>; optional):<br />
If the button/input is a submit button (e.g. type=&rdquo;submit&rdquo;), this<br />
attribute sets the submission method to use during form submission<br />
(GET, POST, etc.). If this attribute is specified, it overrides the<br />
method attribute of the button&rsquo;s form owner.</p>
<p><strong><code>formNoValidate</code></strong> (<em>a value equal to: &lsquo;formNoValidate&rsquo;, &lsquo;formnovalidate&rsquo; or &lsquo;FORMNOVALIDATE&rsquo; | boolean</em>; optional):<br />
If the button/input is a submit button (e.g. type=&rdquo;submit&rdquo;), this<br />
boolean attribute specifies that the form is not to be validated when<br />
it is submitted. If this attribute is specified, it overrides the<br />
novalidate attribute of the button&rsquo;s form owner.</p>
<p><strong><code>formTarget</code></strong> (<em>string</em>; optional):<br />
If the button/input is a submit button (e.g. type=&rdquo;submit&rdquo;), this<br />
attribute specifies the browsing context (for example, tab, window, or<br />
inline frame) in which to display the response that is received after<br />
submitting the form. If this attribute is specified, it overrides the<br />
target attribute of the button&rsquo;s form owner.</p>
<p><strong><code>name</code></strong> (<em>string</em>; optional):<br />
Name of the element. For example used by the server to identify the<br />
fields in form submits.</p>
<p><strong><code>type</code></strong> (<em>string</em>; optional):<br />
Defines the type of the element.</p>
<p><strong><code>value</code></strong> (<em>string</em>; optional):<br />
Defines a default value which will be displayed in the element on page<br />
load.</p>
<p><strong><code>accessKey</code></strong> (<em>string</em>; optional):<br />
Keyboard shortcut to activate or add focus to the element.</p>
<p><strong><code>className</code></strong> (<em>string</em>; optional):<br />
Often used with CSS to style elements with common properties.</p>
<p><strong><code>contentEditable</code></strong> (<em>string</em>; optional):<br />
Indicates whether the element&rsquo;s content is editable.</p>
<p><strong><code>dir</code></strong> (<em>string</em>; optional):<br />
Defines the text direction. Allowed values are ltr (Left-To-Right) or<br />
rtl (Right-To-Left).</p>
<p><strong><code>draggable</code></strong> (<em>string</em>; optional):<br />
Defines whether the element can be dragged.</p>
<p><strong><code>hidden</code></strong> (<em>a value equal to: &lsquo;hidden&rsquo; or &lsquo;HIDDEN&rsquo; | boolean</em>; optional):<br />
Prevents rendering of given element, while keeping child elements,<br />
e.g. script elements, active.</p>
<p><strong><code>lang</code></strong> (<em>string</em>; optional):<br />
Defines the language used in the element.</p>
<p><strong><code>role</code></strong> (<em>string</em>; optional):<br />
Defines an explicit role for an element for use by assistive<br />
technologies.</p>
<p><strong><code>spellCheck</code></strong> (<em>string</em>; optional):<br />
Indicates whether spell checking is allowed for the element.</p>
<p><strong><code>style</code></strong> (<em>dict</em>; optional):<br />
Defines CSS styles which will override styles previously set.</p>
<p><strong><code>tabIndex</code></strong> (<em>string</em>; optional):<br />
Overrides the browser&rsquo;s default tab order and follows the one<br />
specified instead.</p>
<p><strong><code>title</code></strong> (<em>string</em>; optional):<br />
Text to be displayed in a tooltip when hovering over the element.</p>
<p><strong><code>loading_state</code></strong> (<em>dict</em>; optional):<br />
Object that holds the loading state object coming from dash-renderer.</p>
<p><code>loading_state</code> is a dict with keys:</p>
<ul>
<li>
<p><strong><code>component_name</code></strong> (<em>string</em>; optional):<br />
    Holds the name of the component that is loading.</p>
</li>
<li>
<p><strong><code>is_loading</code></strong> (<em>boolean</em>; optional):<br />
    Determines if the component is loading or not.</p>
</li>
<li>
<p><strong><code>prop_name</code></strong> (<em>string</em>; optional):<br />
    Holds which property is loading.</p>
</li>
</ul>
</div>
</div>
<div class="ssr-dash-core-components-markdown">
</div>
    </div>
    <footer>
        <script id="_dash-config" type="application/json">{"url_base_pathname":null,"requests_pathname_prefix":"\u002f","ui":false,"props_check":false,"show_undo_redo":false,"suppress_callback_exceptions":true,"update_title":null,"children_props":{"dash_core_components":{"Checklist":["options[].label"],"Clipboard":[],"ConfirmDialog":[],"ConfirmDialogProvider":[],"DatePickerRange":[],"DatePickerSingle":[],"Download":[],"Dropdown":["options[].label"],"Geolocation":[],"Graph":[],"Input":[],"Interval":[],"Link":[],"Loading":[],"Location":[],"LogoutButton":[],"Markdown":[],"RadioItems":["options[].label"],"RangeSlider":[],"Slider":[],"Store":[],"Tab":[],"Tabs":[],"Textarea":[],"Tooltip":[],"Upload":[]},"dash_html_components":{"A":[],"Abbr":[],"Acronym":[],"Address":[],"Area":[],"Article":[],"Aside":[],"Audio":[],"B":[],"Base":[],"Basefont":[],"Bdi":[],"Bdo":[],"Big":[],"Blink":[],"Blockquote":[],"Br":[],"Button":[],"Canvas":[],"Caption":[],"Center":[],"Cite":[],"Code":[],"Col":[],"Colgroup":[],"Content":[],"Data":[],"Datalist":[],"Dd":[],"Del":[],"Details":[],"Dfn":[],"Dialog":[],"Div":[],"Dl":[],"Dt":[],"Em":[],"Embed":[],"Fieldset":[],"Figcaption":[],"Figure":[],"Font":[],"Footer":[],"Form":[],"Frame":[],"Frameset":[],"H1":[],"H2":[],"H3":[],"H4":[],"H5":[],"H6":[],"Header":[],"Hgroup":[],"Hr":[],"I":[],"Iframe":[],"Img":[],"Ins":[],"Kbd":[],"Keygen":[],"Label":[],"Legend":[],"Li":[],"Link":[],"Main":[],"MapEl":[],"Mark":[],"Marquee":[],"Meta":[],"Meter":[],"Nav":[],"Nobr":[],"Noscript":[],"ObjectEl":[],"Ol":[],"Optgroup":[],"Option":[],"Output":[],"P":[],"Param":[],"Picture":[],"Plaintext":[],"Pre":[],"Progress":[],"Q":[],"Rb":[],"Rp":[],"Rt":[],"Rtc":[],"Ruby":[],"S":[],"Samp":[],"Script":[],"Section":[],"Select":[],"Shadow":[],"Slot":[],"Small":[],"Source":[],"Spacer":[],"Span":[],"Strike":[],"Strong":[],"Sub":[],"Summary":[],"Sup":[],"Table":[],"Tbody":[],"Td":[],"Template":[],"Textarea":[],"Tfoot":[],"Th":[],"Thead":[],"Time":[],"Title":[],"Tr":[],"Track":[],"U":[],"Ul":[],"Var":[],"Video":[],"Wbr":[],"Xmp":[]},"dash_table":{"DataTable":[]},"dash_design_kit":{"App":[],"Block":[],"Card":[],"CardFooter":[],"CardHeader":[],"CollapsibleMenu":["title"],"ControlCard":[],"ControlItem":[],"DataCard":[],"DataTable":[],"Footer":["tags"],"FullScreen":["cardRef"],"Graph":["insights.title","insights_conversation[].answer"],"Header":[],"Hero":["tags","primary_controls","secondary_controls"],"Icon":[],"Logo":[],"Menu":[],"Modal":["cardRef"],"Notification":[],"Page":[],"PageFooter":[],"PageHeader":[],"Report":[],"Row":[],"SectionTitle":[],"Sidebar":[],"SidebarCompanion":[],"Tag":[],"Title":[],"_CopyText":null},"dash_bootstrap_components":{"Accordion":[],"AccordionItem":[],"Alert":[],"Badge":[],"Breadcrumb":[],"Button":[],"ButtonGroup":[],"Card":[],"CardBody":[],"CardFooter":[],"CardGroup":[],"CardHeader":[],"CardImg":[],"CardImgOverlay":[],"CardLink":[],"Carousel":[],"Collapse":[],"DropdownMenu":["label"],"DropdownMenuItem":[],"Fade":[],"Form":[],"FormFeedback":[],"FormFloating":[],"FormText":[],"Label":[],"Checkbox":["label"],"Checklist":["options[].label"],"Input":[],"InputGroup":[],"InputGroupText":[],"RadioButton":["label"],"RadioItems":["options[].label"],"Select":[],"Switch":["label"],"Textarea":[],"Col":[],"Container":[],"Row":[],"Stack":[],"ListGroup":[],"ListGroupItem":[],"Modal":[],"ModalBody":[],"ModalFooter":[],"ModalHeader":[],"ModalTitle":[],"Nav":[],"NavItem":[],"NavLink":[],"Navbar":[],"NavbarBrand":[],"NavbarSimple":["brand"],"NavbarToggler":[],"Offcanvas":["title"],"Pagination":[],"Placeholder":[],"Popover":[],"PopoverBody":[],"PopoverHeader":[],"Progress":[],"Spinner":[],"Table":[],"Tab":[],"Tabs":[],"Toast":["header"],"Tooltip":[]},"dash_user_guide_components":{"PageMenu":[],"Sidebar":[]},"dash_bio":{"AlignmentChart":null,"Circos":null,"FornaContainer":null,"Ideogram":null,"Igv":null,"Jsme":null,"Molecule2dViewer":null,"Molecule3dViewer":null,"NeedlePlot":null,"NglMoleculeViewer":null,"OncoPrint":null,"Pileup":null,"SequenceViewer":null,"Speck":null},"dash_cytoscape":{"Cytoscape":null},"dash_embedded":{"ConsumerContext":[],"ConsumerFunction":[]},"dash_ag_grid":{"AgGrid":[]},"components":{"Header":[],"NavLinks":[],"QuickSettings":[],"ShareDialog":[]},"chatbot":{"Chatbot":["chatbot_button"]},"dash_mantine_components":{"Accordion":["chevron"],"AccordionControl":["chevron","icon"],"AccordionItem":[],"AccordionPanel":[],"Navbar":[],"NavbarSection":[],"AppShell":[],"Aside":[],"Footer":[],"Header":[],"Avatar":[],"AvatarGroup":[],"Button":["leftIcon","rightIcon"],"ButtonGroup":[],"Card":[],"CardSection":[],"Checkbox":["label","description","error"],"CheckboxGroup":["label","description","error"],"Chip":[],"ChipGroup":["label","description","error"],"ColorInput":["eyeDropperIcon","icon","rightSection","label","description","error"],"ColorPicker":[],"Col":[],"Grid":[],"HoverCard":[],"HoverCardDropdown":[],"HoverCardTarget":[],"BackgroundImage":[],"Image":["placeholder","caption"],"List":["icon"],"ListItem":["icon"],"Menu":[],"MenuDivider":[],"MenuDropdown":[],"MenuItem":["icon","rightSection"],"MenuLabel":[],"MenuTarget":[],"Popover":[],"PopoverDropdown":[],"PopoverTarget":[],"Radio":["label","description","error"],"RadioGroup":["label","description","error"],"Autocomplete":["icon","rightSection","label","description","error","nothingFound"],"MultiSelect":["icon","rightSection","label","description","error","nothingFound"],"Select":["icon","rightSection","label","description","error","nothingFound"],"RangeSlider":["marks[].label","label","thumbChildren"],"Slider":["marks[].label","label","thumbChildren"],"Stepper":["icon","completedIcon","progressIcon"],"StepperCompleted":[],"StepperStep":["icon","completedIcon","progressIcon","label","description"],"Tab":["rightSection","icon"],"Tabs":[],"TabsList":[],"TabsPanel":[],"JsonInput":["validationError","icon","rightSection","label","description","error"],"NumberInput":["icon","rightSection","label","description","error"],"PasswordInput":["icon","rightSection","label","description","error"],"PinInput":["icon","rightSection"],"TextInput":["icon","rightSection","label","description","error"],"Textarea":["icon","rightSection","label","description","error"],"Timeline":[],"TimelineItem":["title","bullet"],"FloatingTooltip":["label"],"Tooltip":["label"],"ActionIcon":[],"Affix":[],"Alert":["title","icon"],"Anchor":[],"AspectRatio":[],"Badge":["leftSection","rightSection"],"Blockquote":["icon","cite"],"Box":[],"Breadcrumbs":["separator"],"Burger":[],"Center":[],"Code":[],"Container":[],"Divider":["label"],"Drawer":["title","closeButtonProps.children"],"Flex":[],"Group":[],"Highlight":[],"Indicator":["label"],"InputWrapper":["label","description","error"],"Kbd":[],"Loader":[],"LoadingOverlay":["loader"],"Mark":[],"MediaQuery":[],"Modal":["title","closeButtonProps.children"],"NavLink":["label","description","icon","rightSection"],"Pagination":[],"Paper":[],"Progress":["sections[].tooltip"],"Rating":["emptySymbol","fullSymbol"],"RingProgress":["label","sections[].tooltip"],"ScrollArea":[],"SegmentedControl":[],"SimpleGrid":[],"Skeleton":[],"Space":[],"Spoiler":["hideLabel","showLabel"],"Stack":[],"Switch":["label","offLabel","onLabel","thumbIcon","description","error"],"Table":[],"Text":[],"ThemeIcon":[],"Title":[],"TransferList":[],"DateInput":["icon","rightSection","label","description","error","nextIcon","previousIcon","modalProps.title","modalProps.closeButtonProps.children"],"DatePicker":["nextIcon","previousIcon"],"DatePickerInput":["nextIcon","previousIcon","modalProps.title","modalProps.closeButtonProps.children","icon","rightSection","label","description","error"],"DatesProvider":[],"TimeInput":["icon","rightSection","label","description","error"],"Notification":["icon","title","message"],"Notifications":[],"Prism":[],"MantineProvider":[]},"dash_iconify":{"DashIconify":null},"dash_canvas":{"DashCanvas":null},"dash_player":{"DashPlayer":[]},"dash_vtk":{"Algorithm":null,"Calculator":null,"CellData":null,"DataArray":null,"FieldData":null,"GeometryRepresentation":null,"GlyphRepresentation":null,"ImageData":null,"Mesh":null,"PointCloudRepresentation":null,"PointData":null,"PolyData":null,"Reader":null,"ShareDataSet":null,"SliceRepresentation":null,"View":null,"Volume":null,"VolumeController":null,"VolumeDataRepresentation":null,"VolumeRepresentation":null},"dash_vega_components":{"Vega":[]}},"serve_locally":true}</script>
        <script src="/_dash-component-suites/dash/deps/polyfill@7.v2_16_1m1713366194.12.1.min.js"></script>
<script src="/_dash-component-suites/dash/deps/react@16.v2_16_1m1713366194.14.0.min.js"></script>
<script src="/_dash-component-suites/dash/deps/react-dom@16.v2_16_1m1713366194.14.0.min.js"></script>
<script src="/_dash-component-suites/dash/deps/prop-types@15.v2_16_1m1713366194.8.1.min.js"></script>
<script src="/_dash-component-suites/dash_design_kit/dash_design_kit.v1_10_0m1713366171.min.js"></script>
<script src="/_dash-component-suites/dash_daq/dash_daq.v0_5_0m1713366174.min.js"></script>
<script src="/_dash-component-suites/dash_bootstrap_components/_components/dash_bootstrap_components.v1_5_0m1713366180.min.js"></script>
<script src="/_dash-component-suites/dash_user_guide_components/dash_user_guide_components.v0_0_8m1713366137.min.js"></script>
<script src="/_dash-component-suites/dash_bio/bundle.v1_0_2m1713366171.js"></script>
<script src="/_dash-component-suites/dash_cytoscape/dash_cytoscape.v0_2_0m1713366179.min.js"></script>
<script src="/_dash-component-suites/dash_embedded/dash_embedded.v2_7_0m1713366171.min.js"></script>
<script src="/_dash-component-suites/dash_ag_grid/dash_ag_grid.v31_0_0m1713366171.min.js"></script>
<script src="/_dash-component-suites/dash_enterprise_libraries/dash_renderer/dash_renderer/dash_renderer.v1_2_0m1713366214.js"></script>
<script src="/_dash-component-suites/dash_enterprise_libraries/components/components/components.v1_2_0m1713366214.js"></script>
<script src="/_dash-component-suites/smart_insights/chatbot/_components/chatbot.v0_0_8m1713366214.js"></script>
<script src="/_dash-component-suites/dash_mantine_components/dash_mantine_components.v0_13_0a3m1713366172.js"></script>
<script src="/_dash-component-suites/dash_iconify/dash_iconify.v0_1_2m1713366173.min.js"></script>
<script src="/_dash-component-suites/dash_canvas/dash_canvas.v0_1_0m1713366179.min.js"></script>
<script src="/_dash-component-suites/dash_player/dash_player.v1_1_0m1713366172.min.js"></script>
<script src="/_dash-component-suites/dash_vtk/dash_vtk.v0_0_9m1713366181.min.js"></script>
<script src="/_dash-component-suites/dash_vega_components/dash_vega_components.v0_8_0devm1713366172.min.js"></script>
<script src="/assets/clientside_example.js?m=1713366137.0"></script>
<script src="/assets/dashAgGridClientsideCallbacks.js?m=1713366137.0"></script>
<script src="/assets/dashAgGridComponentFunctions.js?m=1713366137.0"></script>
<script src="/assets/dashAgGridFunctions.js?m=1713366137.0"></script>
<script src="/assets/loading.js?m=1713366138.0"></script>
<script src="/assets/tooltip.js?m=1713366138.0"></script>
<script src="/assets/dash-design-kit/print-handler.js?m=1713366214.0"></script>
<script src="/_dash-component-suites/dash/dash-renderer/build/dash_renderer.v2_16_1m1713366195.min.js"></script>
<script src="/_dash-component-suites/dash/dcc/async-markdown.v2_13_1m1713366195.js"></script>
<script src="/_dash-component-suites/dash/dcc/dash_core_components.v2_13_1m1713366195.js"></script>
<script src="/_dash-component-suites/dash/dcc/dash_core_components-shared.v2_13_1m1713366195.js"></script>
<script src="/_dash-component-suites/dash/html/dash_html_components.v2_0_17m1713366194.min.js"></script>
<script src="/_dash-component-suites/dash/dash_table/bundle.v5_2_10m1713366194.js"></script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["916f91df064c03db7a8a469965069fcc"] = 
    function(index, theme, presets) {
        if (index.every(x => x === undefined)) {
            return Array(2).fill(window.dash_clientside.no_update);
        }

        theme = theme.toLowerCase();
        var idx = dash_clientside.callback_context.triggered_id["index"];
        var active_preset = presets[`${theme}-style`];
        active_preset["accent"] = presets[theme][idx]["accent"];
        active_preset["user_color"] = presets[theme][idx]["user_color"];
        return [
            active_preset,
            [
                active_preset["container_background"],
                active_preset["line_separator_color"],
                active_preset["header_title_color"],
                active_preset["header_subtitle_color"],
                active_preset["no_header_close_button_shadow_color"],
                active_preset["accent"],
                active_preset["user_color"],
                active_preset["assistant_background"],
                active_preset["assistant_color"],
                active_preset["response_action_button"],
                active_preset["chat_action_button_background_color"],
                active_preset["chat_action_button_color"],
            ]
        ];
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["9b23397fa4d6430b1216471d79a04c4b"] = 
    function(){
        console.log(dash_clientside.callback_context);
        const triggered_id = dash_clientside.callback_context.triggered_id;
        return "triggered id: " + triggered_id
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["cf9ec6908758fb89ab014a6ce9817520"] = 
    function () {
        document.addEventListener('keydown', function(e) {

            if (e.ctrlKey && e.keyCode == 82) {
                // Simulate getting new data
                newData = JSON.stringify(new Date())

                // Update dcc.Store with ID store-events
                dash_clientside.set_props("store-events", {data: newData})

                event.preventDefault()
                event.stopPropagation()
                return dash_clientside.no_update;
            }
        });
        return dash_clientside.no_update;
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["ec11c9ccf34e0f96b162e9b47e54bb54"] = 
    function () {            

         var printContents = document.getElementById('grid-print-area').innerHTML;
         var originalContents = document.body.innerHTML;

         document.body.innerHTML = printContents;

         window.print();

         document.body.innerHTML = originalContents;      
         location.reload()                              

        return window.dash_clientside.no_update
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["c68d712a9cfa59d0b000a0950f687e5f"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer1) window._slicer_slicer1 = {};
            let private_state = window._slicer_slicer1;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["57e6fbe4bdf13b209addea6f23cf0ca0"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer1) window._slicer_slicer1 = {};
            let private_state = window._slicer_slicer1;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer1-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["0bba8ae99f6075e92a2fd156897a54a1"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer2) window._slicer_slicer2 = {};
            let private_state = window._slicer_slicer2;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["028dc7f444313744b07134cb8cec421a"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer2) window._slicer_slicer2 = {};
            let private_state = window._slicer_slicer2;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer2-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["c4ff0d7cabb1720d6259fcf465dbac6d"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer3) window._slicer_slicer3 = {};
            let private_state = window._slicer_slicer3;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["9227fe57c4a565dbcf8caa3e6608b68b"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer3) window._slicer_slicer3 = {};
            let private_state = window._slicer_slicer3;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer3-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["1c59926d9fc28df84b9726d49ca31aa5"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer4) window._slicer_slicer4 = {};
            let private_state = window._slicer_slicer4;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f9c881fde82e3997c3cbf5cd5ce113b4"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer4) window._slicer_slicer4 = {};
            let private_state = window._slicer_slicer4;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer4-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["9cabb076d11534d2070aaa0f9b21c669"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer5) window._slicer_slicer5 = {};
            let private_state = window._slicer_slicer5;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a9f1f38c2210c56952ab32639b940da3"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer5) window._slicer_slicer5 = {};
            let private_state = window._slicer_slicer5;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer5-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["35b9b18168ee414534aeabab6384ece9"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer6) window._slicer_slicer6 = {};
            let private_state = window._slicer_slicer6;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a0410a4f15683e04a7953ff7171d6322"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer6) window._slicer_slicer6 = {};
            let private_state = window._slicer_slicer6;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer6-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["75e6bc3a3199ab8d1fdbbdf4bed9710c"] = 
        function update_setpos_from_click(data, index, info) {
            if (data && data.points && data.points.length) {
                let point = data["points"][0];
                let xyz = [point["x"], point["y"]];
                let depth = info.offset[2] + index * info.stepsize[2];
                xyz.splice(2 - info.axis, 0, depth);
                return xyz;
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["8f964b8aef121a06417ed5639bf46b86"] = 
        function update_slider_value(positions, cur_index, info) {
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (!trigger.value) continue;
                let pos = trigger.value[2 - info.axis];
                if (typeof pos !== 'number') continue;
                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);
                if (index == cur_index) continue;
                return Math.max(0, Math.min(info.size[2] - 1, index));
            }
            return dash_clientside.no_update;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["27b81951a337a3d83b9ce234413b9537"] = 
        function update_rate_limiting_info(index, relayoutData, n_intervals) {

            if (!window._slicer_slicer7) window._slicer_slicer7 = {};
            let private_state = window._slicer_slicer7;
            let now = window.performance.now();

            // Get whether the slider was moved, layout was changed, or timer ticked
            let slider_value_changed = false;
            let graph_layout_changed = false;
            let timer_ticked = false;
            for (let trigger of dash_clientside.callback_context.triggered) {
                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;
                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;
                if (trigger.prop_id.indexOf('graph') >= 0) {
                    for (let key in relayoutData) {
                        if (key.startsWith("xaxis.range") || key.startsWith("yaxis.range")) {
                            graph_layout_changed = true;
                        }
                    }
                }
            }

            // Set timeout and whether to disable the timer
            let disable_timer = false;
            if (slider_value_changed) {
                private_state.timeout = now + 200;
            } else if (graph_layout_changed) {
                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom
            } else if (!n_intervals) {
                private_state.timeout = now + 100;  // initialize
            } else if (!private_state.timeout) {
                disable_timer = true;
            }

            return disable_timer;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["fed84ee9b4fc95d53195903d1c09d104"] = 
        function update_state(n_intervals, index, info, figure) {

            if (!window._slicer_slicer7) window._slicer_slicer7 = {};
            let private_state = window._slicer_slicer7;
            let now = window.performance.now();

            // Ready to apply and stop the timer, or return early?
            if (!(private_state.timeout && now >= private_state.timeout)) {
                return dash_clientside.no_update;
            }
            // Give the plot time to settle the initial axis ranges
            if (n_intervals < 5) {
                return dash_clientside.no_update;
            }

            // Disable the timer
            private_state.timeout = 0;

            // Calculate view range based on the volume
            let xrangeVol = [
                info.offset[0] - 0.5 * info.stepsize[0],
                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]
            ];
            let yrangeVol = [
                info.offset[1] - 0.5 * info.stepsize[1],
                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]
            ];

            // Get view range from the figure. We make range[0] < range[1]
            let xrangeFig = figure.layout.xaxis.range
            let yrangeFig = figure.layout.yaxis.range;
            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];
            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];

            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible
            let plotSize = [400, 400];  // This estimate results in ok results
            let graphDiv = document.getElementById('slicer7-graph');
            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];
            if (plotDiv && plotDiv._fullLayout)
                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];
            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];
            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];
            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];

            // Combine the ranges
            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];
            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];

            // Create new state
            let new_state = {
                index: index,
                index_changed: false,
                xrange: xrange,
                yrange: yrange,
                zpos: info.offset[2] + index * info.stepsize[2],
                axis: info.axis,
                color: info.color,
            };
            if (index != private_state.last_index || info.infoid != private_state.infoid) {
                private_state.last_index = index;
                new_state.index_changed = true;
            }
            private_state.infoid = info.infoid;  // infoid changes on hot reload
            return new_state;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a289fc0e674267642125023ad1cc5623"] = 
        function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {

            // Prepare traces
            let slice_trace = {
                type: 'image',
                x0: info.offset[0],
                y0: info.offset[1],
                dx: info.stepsize[0],
                dy: info.stepsize[1],
                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'
            };
            let overlay_trace = {...slice_trace};
            overlay_trace.hoverinfo = 'skip';
            overlay_trace.source = overlays[index] || '';
            overlay_trace.hovertemplate = '';
            let new_traces = [slice_trace, overlay_trace];

            // Use full data, or use thumbnails
            if (index == server_data.index) {
                slice_trace.source = server_data.slice;
            } else {
                slice_trace.source = thumbnails[index];
                // Scale the image to take the exact same space as the full-res
                // version. Note that depending on how the low-res data is
                // created, the pixel centers may not be correctly aligned.
                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];
                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];
                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];
                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];
            }

            // Has the image data even changed?
            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }
            if (new_traces[0].source == current_traces[0].source &&
                new_traces[1].source == current_traces[1].source)
            {
                new_traces = dash_clientside.no_update;
            }
            return new_traces;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["f339c51ca4326e401d37debce3ca77f7"] = 
        function update_indicator_traces(states, info, thisState) {
            let traces = [];

            for (let state of states) {
                if (!state) continue;
                let zpos = [state.zpos, state.zpos];
                let trace = null;
                if        (info.axis == 0 && state.axis == 1) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 0 && state.axis == 2) {
                    trace = {x: zpos, y: state.xrange};
                } else if (info.axis == 1 && state.axis == 2) {
                    trace = {x: zpos, y: state.yrange};
                } else if (info.axis == 1 && state.axis == 0) {
                    trace = {x: state.xrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 0) {
                    trace = {x: state.yrange, y: zpos};
                } else if (info.axis == 2 && state.axis == 1) {
                    trace = {x: zpos, y: state.yrange};
                }
                if (trace) {
                    trace.line = {color: state.color, width: 1};
                    traces.push(trace);
                }
            }

            // Show our own color around the image, but only if there are other
            // slicers with the same scene id, on a different axis. We do some
            // math to make sure that these indicators are the same size (in
            // scene coordinates) for all slicers of the same data.
            if (thisState && info.color && traces.length) {
                let fraction = 0.1;
                let lengthx = info.size[0] * info.stepsize[0];
                let lengthy = info.size[1] * info.stepsize[1];
                let lengthz = info.size[2] * info.stepsize[2];
                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average
                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe
                let x1 = thisState.xrange[0];
                let x2 = thisState.xrange[0] + dd;
                let x3 = thisState.xrange[1] - dd;
                let x4 = thisState.xrange[1];
                let y1 = thisState.yrange[0];
                let y2 = thisState.yrange[0] + dd;
                let y3 = thisState.yrange[1] - dd;
                let y4 = thisState.yrange[1];
                traces.push({
                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],
                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],
                    line: {color: info.color, width: 4}
                });
            }

            // Post-process the traces we created above
            for (let trace of traces) {
                trace.type = 'scatter';
                trace.mode = 'lines';
                trace.hoverinfo = 'skip';
                trace.showlegend = false;
            }
            if (thisState) {
                return traces;
            } else {
                return dash_clientside.no_update;
            }
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["020a8f1ee482480054891b1e4caea2b7"] = 
        function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {
            // Collect traces
            let traces = [];
            for (let trace of img_traces) { traces.push(trace); }
            for (let trace of extra_traces) { traces.push(trace); }
            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }
            // Update figure
            let figure = {...ori_figure};
            figure.data = traces;
            return figure;
        }
        ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["737b17422cfe7391f1bcd969e8d43b81"] = 
    function(title, path, params, hash, refreshPage) {
        // trigger a pagemenu rerender and set the document title
        window.history.replaceState(null, null, path + params + hash);
        if (title) { document.title = title; }
        return ["", path, refreshPage];
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["1de45535074f9ee92c79a2354a307227"] = 
    function(refreshPage) {
    if (refreshPage===true) {
        window.location.reload();
    }
    return "";
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["bac9a94288e91eefee142086887be774"] = function(x) {return x};
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["bac9a94288e91eefee142086887be774"] = function(x) {return x};
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["bac9a94288e91eefee142086887be774"] = function(x) {return x};
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["6acc23bd4fd7c6ce7608cc6fe7b7202c"] = 
    function(data, scale) {
        return {
            'data': data,
            'layout': {
                 'yaxis': {'type': scale}
             }
        }
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["a78481a4f6c719909e97053e789187ab"] = 
    async function(value) {
    const response = await fetch(value);
    const data = await response.json();
    return data;
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["fd1b4f76c8ff11908312c46c223af06a"] = 
    function(figure, scale) {
        if(figure === undefined) {
            return {'data': [], 'layout': {}};
        }
        const fig = Object.assign({}, figure, {
            'layout': {
                ...figure.layout,
                'yaxis': {
                    ...figure.layout.yaxis, type: scale
                }
             }
        });
        return fig;
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["441278594b1bf51cecc22b131679c5ad"] = 
    function show_tooltip(hoverData) {
        if(!hoverData) {
            return [false, dash_clientside.no_update];
        }
        var pt = hoverData.points[0];
        return [true, pt.bbox];
    }
    ;
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["44390b7a6fa5102bd9f74b36a1c0fa9f"] = async function (changedCell, forceRefresh) {
        gridApi = await dash_ag_grid.getApiAsync('styling-cells-other-col')
        forceRefresh.length != 0 && gridApi.refreshCells({force: true, columns: ['employee']})
        return window.dash_clientside.no_update    
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["c097b9f1ead2ba09a8940d8d3c5b26ca"] = async (n) => {
        if (n) {
            const gridApi =  await dash_ag_grid.getApiAsync("grid-flash-cells-custom")

            var rowCount = gridApi.getDisplayedRowCount();        
            // pick 20 cells at random to update
            for (var i = 0; i < 20; i++) {
              var row = Math.floor(Math.random() * rowCount);
              var rowNode = gridApi.getDisplayedRowAtIndex(row);
              var col = ['a', 'b', 'c', 'd', 'e', 'f'][i % 6];
              rowNode.setDataValue(col, Math.floor(Math.random() * 10000));
            }        
        }
        return dash_clientside.no_update
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["d871ada825b1369cdf7c699977d80453"] = async  (n) =>  {
        if (n) {
            const gridApi =  await dash_ag_grid.getApiAsync("grid-flash-cells-custom")

            // pick row 4 and 5
            var rowNode1 = gridApi.getDisplayedRowAtIndex(4);
            var rowNode2 = gridApi.getDisplayedRowAtIndex(5);
            
            // flash whole row, so leave column selection out
            gridApi.flashCells({ 
              rowNodes: [rowNode1, rowNode2],  
              flashDelay: 3000,
              fadeDelay: 2000, 
            });
        }
        return dash_clientside.no_update
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["603970dfb0b6cb56a770cf186b8ba583"] = async (n) => {
        if (n) {
            const gridApi =  await dash_ag_grid.getApiAsync("grid-flash-cells")

            var rowCount = gridApi.getDisplayedRowCount();        
            // pick 20 cells at random to update
            for (var i = 0; i < 20; i++) {
              var row = Math.floor(Math.random() * rowCount);
              var rowNode = gridApi.getDisplayedRowAtIndex(row);
              var col = ['a', 'b', 'c', 'd', 'e', 'f'][i % 6];
              rowNode.setDataValue(col, Math.floor(Math.random() * 10000));
            }        
        }
        return dash_clientside.no_update
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["9ded2219ad0994fd2f5d9611c5067c6e"] = async  (n) => {
        if (n) {
            const gridApi =  await dash_ag_grid.getApiAsync("grid-flash-cells")
            
            // flash row 4 col 'c'
            var rowNode = gridApi.getDisplayedRowAtIndex(4);
            gridApi.flashCells({ rowNodes: [rowNode], columns: ['c'] });
        }
        return dash_clientside.no_update
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["c05126f793fafb65b90f2e9b773e699e"] = async (n) => {
        if (n) {
            const gridApi =  await dash_ag_grid.getApiAsync("grid-flash-cells")

            // pick row 4 and 5
            var rowNode1 = gridApi.getDisplayedRowAtIndex(4);
            var rowNode2 = gridApi.getDisplayedRowAtIndex(5);
            
            // flash whole row, so leave column selection out
            gridApi.flashCells({ rowNodes: [rowNode1, rowNode2] });
        }
        return dash_clientside.no_update
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["43b949c1fadece4b590070045a5a3bff"] = async (n) => {
         if (n) {
           const gridApi = await dash_ag_grid.getApiAsync("grid-flash-cells");
           gridApi.flashCells({ columns: ['c', 'd'] });
        }
        return dash_clientside.no_update;
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["578761413470259ceb606b75a880ed53"] = function (rowId) {
        if (rowId) {
            grid = dash_ag_grid.getApi("grid-scroll-to-pagination")        
            rowIndex = grid.getRowNode(rowId).rowIndex        
            pageTarget = Math.floor(rowIndex / grid.paginationGetPageSize())
            grid.paginationGoToPage(pageTarget)
        }
        return {"rowId": rowId.toString()}
    };
</script>
<script>
var clientside = window.dash_clientside = window.dash_clientside || {};
var ns = clientside["_dashprivate_clientside_funcs"] = clientside["_dashprivate_clientside_funcs"] || {};
ns["c49927592154cdef683f73b893ca3711"] = function (rowId) {
        if (rowId) {
            grid = dash_ag_grid.getApi("grid-scroll-to-group")
            grid.setRowNodeExpanded(grid.getRowNode(rowId), true, true)
        }
        return {"rowId": rowId.toString()}
    };
</script>
        <script id="_dash-renderer" type="application/javascript">var renderer = new DashRenderer();</script>
    </footer>
    <div id="markprompt" />
    
<script>
  window.onUsersnapCXLoad = function(api) {
    api.init();
  }
  var script = document.createElement('script');
  script.defer = 1;
  script.src = 'https://widget.usersnap.com/global/load/c591243c-ea62-42c1-9af3-a1829dfb78cc?onload=onUsersnapCXLoad';
  document.getElementsByTagName('head')[0].appendChild(script);
</script>

    
      <script type="module">

        // References URL link formatter
        const getHref = (result) => {
          var path = result.file.path;

          // If the source is not plotly.com/python, then it should be a relative path
          if (!path.startsWith("https://plotly.com/python")) {
            var urlObject = new URL(path);
            path = urlObject.pathname;
          }

          if (result && result.meta && result.meta.leadHeading && result.meta.leadHeading.id) {
            path = (path + "#" + result.meta.leadHeading.id);
          }
          if (result && result.meta && result.meta.leadHeading && result.meta.leadHeading.value) {
            path =  (path + "#" + result.meta.leadHeading.slug);
          }
          return path;
        };

        const getLabel = (reference) => {
         var label = reference.meta?.leadHeading?.value || reference.file?.title;
          label = label.replace(/[^\x00-\x7F]/g, "");
          while (label.includes("plotly-logomark")) {
              label = label.replace("plotly-logomark", "");
          }
          return label;
        };

        const setCookie = (name, value, days) => {
         const expires = new Date();
         expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
         document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        };

        const getCookie = (name) => {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.startsWith(name + '=')) {
                    return cookie.substring(name.length + 1);
                }
            }
        return null;
        };

        const getUniqueID = () => {
            const storedID = getCookie("plotly-chatbot-cookie");

            if (storedID) {
                return storedID;
            } else {
                const newID = generateUniqueID();
                setCookie("plotly-chatbot-cookie", newID, 365);
                return newID;
            }
        };

        const generateUniqueID = () => {
            return Date.now().toString();
        };


      window.markprompt = {
        projectKey: 'pk_0upevf7bcscej8JQMALYiqmXoWQkltw3',
        container: '#markprompt',
        options: {
        sticky: true,
        close: { hasIcon: true },
          chat: {
            systemPrompt: "- You are an enthusiastic company representative from Plotly who loves to help people!\
- Never give code examples which are not provided in the docs, and don't give code examples in other languages than Python.",
            defaultView: {
              message: "Welcome to Plotly's AI Assistant",
              promptsHeading: 'Popular questions',
              prompts: [
                'How can I get started with Dash?',
                'How can I customize the layout in Dash?',
                'How can I change the color of graph labels?',
                'How do I move the legend to the top of the graph?',
              ],
            },
              conversationMetadata: {
                "userid": getUniqueID(),
                "source": "dash-docs",
                },
            enabled: true,
            model: 'gpt-3.5-turbo',
            maxTokens: 2000,
            errorText: "Sorry, I'm having some connection issues. Please try again in a few minutes.",
          },
          search: {
            enabled: false,
            getHref: getHref
          },
          references: {
            heading: 'References',
            getHref: getHref,
            getLabel: getLabel
          },
          feedback: {
            enabled: true
          },
          trigger: {
            buttonLabel: 'Ask AI',
            iconSrc: '/assets/markprompt_chat.svg'
          },
          branding: {
            type: 'text'
          }
        }
      }
    </script>
    
    
<script type="module" src="https://esm.sh/@markprompt/web@0.24.0/init"></script>

</body></html>|0K      f$f$F
f$   \    O^partitionKey=%28https%2Cplotly.com%29,:https://dash.plotly.com/dash-html-components/button strongly-framed 1 security-info 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 request-method GET response-head HTTP/1.1 200 OK
Report-To: {"group":"heroku-nel","max_age":3600,"endpoints":[{"url":"https://nel.heroku.com/reports?ts=1713694604&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=JtV94ep2Onnxp099N9W97oZzi3ncC93bbLMt6EHL5aU%3D"}]}
Reporting-Endpoints: heroku-nel=https://nel.heroku.com/reports?ts=1713694604&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=JtV94ep2Onnxp099N9W97oZzi3ncC93bbLMt6EHL5aU%3D
Nel: {"report_to":"heroku-nel","max_age":3600,"success_fraction":0.005,"failure_fraction":0.05,"response_headers":["Via"]}
Server: gunicorn
Date: Sun, 21 Apr 2024 10:16:44 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 141673
Via: 1.1 vegur
 original-response-headers Report-To: {"group":"heroku-nel","max_age":3600,"endpoints":[{"url":"https://nel.heroku.com/reports?ts=1713694604&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=JtV94ep2Onnxp099N9W97oZzi3ncC93bbLMt6EHL5aU%3D"}]}
Reporting-Endpoints: heroku-nel=https://nel.heroku.com/reports?ts=1713694604&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=JtV94ep2Onnxp099N9W97oZzi3ncC93bbLMt6EHL5aU%3D
Nel: {"report_to":"heroku-nel","max_age":3600,"success_fraction":0.005,"failure_fraction":0.05,"response_headers":["Via"]}
Connection: keep-alive
Server: gunicorn
Date: Sun, 21 Apr 2024 10:16:44 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 141673
Via: 1.1 vegur
 ctid 1 uncompressed-len 0 net-response-time-onstart 555 net-response-time-onstop 927  )i